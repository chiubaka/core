{"version":3,"sources":["../src/api/reducers/index.ts"],"names":[],"mappings":"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","file":"../../../api/reducers/index.js","sourcesContent":["import { Action } from \"redux\";\nimport { isNullOrUndefined } from \"util\";\n\nimport { IApiDeleteResponse, IApiResponse, IApiUpdateResponse, ModelApi, SearchableModelApi } from \"../actions\";\nimport { IModel, IModelById, IModelIndex } from \"../model\";\n\nexport declare type ModelFilterFunction<T> = (model: T) => boolean;\nexport declare type ModelEqualityFunction<T> = (model1: T, model2: T) => boolean;\nexport declare type GetObjectsReducer<StateType, ModelType> = (objects: ModelType[]) => StateType;\nexport declare type MergeObjectReducer<StateType, ModelType> = (\n  state: StateType,\n  object: ModelType,\n  locator?: any,\n) => StateType;\nexport declare type ObjectLocatorFunction<StateType, ModelType> = (state: StateType, object: ModelType) => any;\n\n// By default, filter nothing out.\nfunction defaultModelFilterFunction<T>(_object: T) {\n  return true;\n}\n\n// By default, consider nothing equal and always update. This is usually more\n// work than we need to do.\nfunction defaultModelEqualityFunction<T extends IModel>(_object1: T, _object2: T) {\n  return false;\n}\n\nfunction modelIdEquality<T extends IModel>(object1: T, object2: T) {\n  return object1.id === object2.id;\n}\n\nfunction propertyExistsInState(propertyName: string, state: any, object: any) {\n  const property = object[propertyName];\n  return state.hasOwnProperty(property);\n}\n\ninterface IModelApiReducerOptions<StateT, ModelT extends IModel> {\n  Apis: Array<ModelApi<ModelT>>;\n  initialState: StateT;\n  // Handles adding numerous objects to the state, e.g. on initial load.\n  onBulkObjectAdd: GetObjectsReducer<StateT, ModelT>;\n  // Hanldes adding a single object to the state.\n  onObjectAdd: MergeObjectReducer<StateT, ModelT>;\n  // Handles removing a single object from the state. May be called in contexts\n  // where the object is not in the state for certain. Must not error out in this\n  // situation.\n  onObjectRemove: MergeObjectReducer<StateT, ModelT>;\n  // Optionally helps to optimize determining whether or not an object is already\n  // in the state. Providing this allows us to avoid removal calls in certain cases.\n  // We expect it to return a locator which will get passed to onObjectAdd or onObjectRemove.\n  // If you provide this function, your onObjectAdd and onObjectRemove can optionally use\n  // the locator as metadata during the operation.\n  // Originally this was just a function returning a boolean for existence. It morphed this\n  // way because e.g. for array states, we need to update the object in places when possible\n  // otherwise we may cause an unexpected re-order in the UI.\n  objectLocator?: ObjectLocatorFunction<StateT, ModelT>;\n  // Defines the filter scope of this reducer. By default, no objects are ever filtered\n  // out. However, if one only cares about objects with certain attributes (e.g. Tasks that\n  // are in a certain state), this can be used to quickly construct reducers with limited\n  // scope based off of a less specific API.\n  modelFilter?: ModelFilterFunction<ModelT>;\n  // Defines whether or not two model objects are equal. By default, we always return false.\n  // Providing this is an optimization, which allows us to short circuit some work in some cases.\n  modelEquality?: ModelEqualityFunction<ModelT>;\n}\n\ninterface IModelApiReducerByPropertyOptions<T extends IModel> extends IModelApiReducerSimpleOptions<T> {\n  propertyName: keyof T;\n}\n\ninterface IModelApiReducerSimpleOptions<T extends IModel> {\n  Api: ModelApi<T>;\n  modelFilter?: ModelFilterFunction<T>;\n  modelEquality?: ModelEqualityFunction<T>;\n}\n\ninterface ISearchableModelApiReducerOptions<T extends IModel> {\n  Api: SearchableModelApi<T>;\n}\n\nexport function modelApiReducer<StateT, ModelT extends IModel>(options: IModelApiReducerOptions<StateT, ModelT>) {\n  const {\n    Apis,\n    initialState,\n    onBulkObjectAdd,\n    onObjectAdd,\n    onObjectRemove,\n    objectLocator,\n  } = options;\n\n  const modelFilter = options.modelFilter || defaultModelFilterFunction;\n  const modelEquality = options.modelEquality || defaultModelEqualityFunction;\n\n  const getAllTypes = new Set(Apis.map((Api) => Api.SUCCESSFUL_GET_ALL_TYPE));\n  const getTypes = new Set(Apis.map((Api) => Api.SUCCESSFUL_GET_TYPE));\n  const createTypes = new Set(Apis.map((Api) => Api.SUCCESSFUL_CREATE_TYPE));\n  const updateTypes = new Set(Apis.map((Api) => Api.SUCCESSFUL_UPDATE_TYPE));\n  const deleteTypes = new Set(Apis.map((Api) => Api.SUCCESSFUL_DELETE_TYPE));\n\n  return (state: StateT = initialState, action: Action): StateT => {\n    if (getAllTypes.has(action.type)) {\n      const objects = (action as IApiResponse<ModelT[]>).payload.filter(modelFilter);\n      return onBulkObjectAdd(objects);\n    } else if (createTypes.has(action.type)) {\n      const object = (action as IApiResponse<ModelT>).payload;\n      if (modelFilter(object)) {\n        return onObjectAdd(state, object);\n      }\n    } else if (getTypes.has(action.type)) {\n      const object = (action as IApiResponse<ModelT>).payload;\n      if (modelFilter(object)) {\n        const locator = objectLocator ? objectLocator(state, object) : null;\n        if (isNullOrUndefined(locator)) {\n          return onObjectAdd(state, object);\n        } else {\n          return onObjectAdd(onObjectRemove(state, object, locator), object, locator);\n        }\n      }\n    } else if (updateTypes.has(action.type)) {\n      const { original, payload } = (action as IApiUpdateResponse<ModelT>);\n      if (!modelFilter(original) && modelFilter(payload)) {\n        // If the original object didn't match this reducer's filter scope, but the\n        // new one does, then we know we can just add the new object because the old\n        // one isn't already in our state (we ignored it before)\n        return onObjectAdd(state, payload);\n      } else if (modelFilter(original) && !modelFilter(payload)) {\n        // If the original object matched this reducer's filter scope, but the new\n        // one doesn't, then we know we can just remove the existing tracked object\n        // and ignore the new one.\n        return onObjectRemove(state, original);\n      } else if (modelFilter(original) && modelFilter(payload)) {\n        // If both the original and the new object are in this reducer's filter scope\n        // then we should do a removal of the old object and an insertion of the new\n        // one. However, don't bother doing this if we detect that the objects are\n        // actually the same.\n        if (modelEquality && !modelEquality(original, payload)) {\n          const locator = objectLocator ? objectLocator(state, original) : null;\n          return onObjectAdd(onObjectRemove(state, original, locator), payload, locator);\n        }\n      }\n    } else if (deleteTypes.has(action.type)) {\n      const deleted = (action as IApiDeleteResponse<ModelT>).deleted;\n      return onObjectRemove(state, deleted);\n    }\n    return state;\n  };\n}\n\nexport function modelApiById<T extends IModel>(options: IModelApiReducerSimpleOptions<T>) {\n  return modelApiByUniqueProperty({\n    ...options,\n    propertyName: \"id\",\n  });\n}\n\nexport function modelApiByUniqueProperty<T extends IModel>(options: IModelApiReducerByPropertyOptions<T>) {\n  const {\n    Api,\n    propertyName,\n    modelFilter,\n    modelEquality,\n  } = options;\n\n  return modelApiReducer({\n    Apis: [Api],\n    initialState: {},\n    onBulkObjectAdd: (objects: T[]) => {\n      const newState: IModelById<T> = {};\n      objects.forEach((object) => {\n        const property = object[propertyName];\n        newState[property] = object;\n      });\n      return newState;\n    },\n    onObjectAdd: (state: IModelById<T>, object: T) => {\n      const newState = {...state};\n      const property = object[propertyName];\n      newState[property] = object;\n      return newState;\n    },\n    onObjectRemove: (state: IModelById<T>, object: T) => {\n      const property = object[propertyName];\n      const newState = {...state};\n      delete newState[property];\n      return newState;\n    },\n    objectLocator: propertyExistsInState.bind(this, propertyName),\n    modelFilter,\n    modelEquality,\n  });\n}\n\nexport function modelApiByProperty<T extends IModel>(options: IModelApiReducerByPropertyOptions<T>) {\n  const {\n    Api,\n    propertyName,\n    modelFilter,\n    modelEquality,\n  } = options;\n\n  function addToIndex(index: IModelIndex<T>, object: T) {\n    const property: any = object[propertyName];\n    if (!index.hasOwnProperty(property)) {\n      index[property] = [];\n    }\n\n    index[property].push(object);\n  }\n\n  function removeFromIndex(index: IModelIndex<T>, object: T) {\n    const property: any = object[propertyName];\n    if (!index.hasOwnProperty(property)) {\n      return;\n    }\n\n    const newList = index[property].filter((existingObject) => {\n      return existingObject.id !== object.id;\n    });\n\n    if (newList.length === 0) {\n      delete index[property];\n    } else {\n      index[property] = newList;\n    }\n  }\n\n  return modelApiReducer({\n    Apis: [Api],\n    initialState: {},\n    onBulkObjectAdd: (objects: T[]) => {\n      const newState: IModelIndex<T> = {};\n      objects.forEach((object) => {\n        addToIndex(newState, object);\n      });\n      return newState;\n    },\n    onObjectAdd: (state: IModelIndex<T>, object: T) => {\n      const newState = {...state};\n      addToIndex(newState, object);\n      return newState;\n    },\n    onObjectRemove: (state: IModelIndex<T>, object: T) => {\n      const newState = {...state};\n      removeFromIndex(newState, object);\n      return newState;\n    },\n    objectLocator: propertyExistsInState.bind(this, propertyName),\n    modelFilter,\n    modelEquality,\n  });\n}\n\n// TODO: The below works, and handles refactoring modelApiAsArray to use the modelApiReducer\n// as a scaffold, but has a small bug\nexport function modelApiAsArray<T extends IModel>(options: IModelApiReducerSimpleOptions<T>) {\n  const {\n    Api,\n    modelFilter,\n    modelEquality,\n  } = options;\n\n  return modelApiReducer({\n    Apis: [Api],\n    initialState: [],\n    onBulkObjectAdd: (objects: T[]) => {\n      return objects;\n    },\n    onObjectAdd: (state: T[], object: T, locator: number) => {\n      if (!isNullOrUndefined(locator) && locator >= 0) {\n        const newState = [...state];\n        newState.splice(locator, 0, object);\n        return newState;\n      }\n\n      return [...state, object];\n    },\n    onObjectRemove: (state: T[], object: T, locator: number) => {\n      const index = isNullOrUndefined(locator) ? state.findIndex(modelIdEquality.bind(this, object)) : locator;\n\n      if (index === -1) {\n        console.warn(\"API attempt to remove an object which does not exist on client.\");\n        return state;\n      }\n\n      const newState = [...state];\n      newState.splice(index, 1);\n      return newState;\n    },\n    objectLocator: (state: T[], object: T) => {\n      const index = state.findIndex(modelIdEquality.bind(this, object));\n      return index === -1 ? null : index;\n    },\n    modelFilter,\n    modelEquality,\n  });\n}\n\nexport function searchableModelApiAsArray<ModelT extends IModel>(options: ISearchableModelApiReducerOptions<ModelT>) {\n  const Api = options.Api;\n\n  return (state: ModelT[] = [], action: Action): ModelT[] => {\n    if (action.type === Api.SUCCESSFUL_SEARCH_TYPE) {\n      return (action as IApiResponse<ModelT[]>).payload;\n    } else if (action.type === Api.SUCCESSFUL_UPDATE_TYPE) {\n      const updated = (action as IApiUpdateResponse<ModelT>).payload;\n      const newState = [...state];\n      const index = newState.findIndex((model: ModelT) => model.id === updated.id);\n      if (index !== -1) {\n        newState[index] = updated;\n      }\n\n      return newState;\n    }\n    return state;\n  };\n}\n"]}